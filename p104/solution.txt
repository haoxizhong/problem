p1:
首先显而易见的是，跳楼的过程中楼房的高度应该是单调的，所以我们第一步可以按照从低到高排序，这样在做动态规划的时候就拥有了明确的转移方向，不存在有效性。
另f[i][j]表示跳到了第i座楼且已经跳了j次楼的最小花费，转移枚举下一次跳到i+1到n中那一座楼即可。
最后出答案枚举所有可能的状态，将花费满足条件的计入答案即可。
难度评估:第1.5题难度

p2:
另a1,a2,……,an为一组答案，那么给出的n*(n-1)/2个数中，最小的一定等于a1+a2，次小的一定等于a1+a3，为了确定a1 a2 a3我们还需要a2+a3的值。由于a1+a4可能小于a2+a3，所以我们不能确定a2+a3的值，那么由于数据范围挺小的，枚举a2+a3是n*(n-1)/2中的哪一个就好了。确定了a2+a3之后我们发现a1 a2 a3的值就都有了，然后a1+a4一定是剩下中最小的，依次类推一个一个解出剩下的数就搞定了。
难度评估：第2题难度

p3：
做法的核心思想是按p的大小分不同的做法，首先注意到p>10000是没有什么意义的，所以我们按照sqrt(10000)=100进行分块来做。
对于p<=100的，我们发现对于p<=100，总共的可能的询问也就只有100*(100-1)/2=4950种(p,v)的取值，所以我们可以预处理这一部分。我们枚举一个p和一个v，对一个(p,v)开一个vector，将所有模p等于v的数全部放到这个vector里面来，那么每次询问的时候，只需要直接在这个vector里面二分区间内有多少个在这个vector里面即可。
对于p>100的，情况就比较多了没法预处理了，但是注意到可能被统计到答案里面的数，只有v,p+v,2p+v…………之类的数，这样可能的数只有sqrt(n)个，所以我们提前对每一个v开一个vector，把所有等于v的数全部放到这个vector里面。之后每一次询问的时候，我们去v,p+v,2p+v……这每一个vector里面二分即可。
这样总的复杂度就是O(nlognsqrt(n))了，就可以过了。vector常数比较大我也不知道能不能过，不过这个也可以直接用数组或者链表实现。
难度评估：第3题难度